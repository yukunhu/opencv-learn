<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <!-- <img src="./img/blend1.png" alt="" id="img1">
    <img src="./img/blend2.png" alt="" id="img2"> -->
    <img src="./img/lena.jpg" alt="" id="lena">
    <!-- <img src="./img/shape.jpg" alt="" id="shape"> -->
    <!-- <img src="./img/coins.jpg" alt="" id="coins"> -->
    <canvas id="output"></canvas>
    <script src="./js/utils.js"></script>
    <script>
        createScript(clahe)

        function clahe(){
            let src = cv.imread('lena')
            let equalDst = new cv.Mat()
            let claheDst = new cv.Mat()
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            cv.equalizeHist(src, equalDst)
            let tileGridSize = new cv.Size(8, 8)
            let clache = new cv.CLAHE(40, tileGridSize)
            clache.apply(src, claheDst)
            cv.imshow('output', equalDst)
            cv.imshow('output', claheDst)
        }

        function equalHistogram(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            cv.equalizeHist(src, dst)
            cv.imshow('output', src)
            cv.imshow('output', dst)
        }

        function histogram(){
            let src = cv.imread('lena')
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            let srcVec = new cv.MatVector()
            srcVec.push_back(src)
            let accumulate = false
            let channels = [0]
            let histSize = [256]
            let ranges = [0, 255]
            let hist = new cv.Mat()
            let mask = new cv.Mat()
            let color = new cv.Scalar(255, 255, 255)
            let scale = 2
            cv.calcHist(srcVec, channels, mask, hist, histSize, ranges, accumulate)
            let result = cv.minMaxLoc(hist, mask)
            let max = result.maxVal
            let dst = new cv.Mat.zeros(src.rows, histSize[0] * scale, cv.CV_8UC3)
            for(let i=0; i<histSize[0]; i++){
                let binVal = hist.data32F[i] * src.rows / max
                let point1 = new cv.Point(i * scale, src.rows - 1)
                let point2 = new cv.Point((i+1)*scale-1, src.rows-binVal)
                cv.rectangle(dst, point1, point2, color, cv.FILLED)
            }
            cv.imshow('output', dst)
        }

        function matchShape(){
            let src = cv.imread('coins')
            let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3)
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            cv.threshold(src, src, 177, 200, cv.THRESH_BINARY)
            let contours = new cv.MatVector()
            let hierarchy = new cv.Mat()
            cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE)
            console.log(contours.size())
            let contourID0 = 10
            let contourID1 = 5
            let color0 = new cv.Scalar(255, 0, 0)
            let color1 = new cv.Scalar(0, 0, 255)
            let result = cv.matchShapes(contours.get(contourID0), contours.get(contourID1), 1, 0)
            cv.drawContours(dst, contours, contourID0, color0, 1, cv.LINE_8, hierarchy, 100)
            cv.drawContours(dst, contours, contourID1, color1, 1, cv.LINE_8, hierarchy, 100)
            cv.imshow('output', dst)
        }
        
        function convexityDefect(){
            let src = cv.imread('shape')
            let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3)
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            cv.threshold(src, src, 100, 200, cv.THRESH_BINARY)
            let contours = new cv.MatVector()
            let hierarchy = new cv.Mat()
            cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE)
            let hull = new cv.Mat()
            let defect = new cv.Mat()
            let cnt = contours.get(0)
            let dist = cv.pointPolygonTest(cnt, new cv.Point(52, 50), true)
            console.log(dist)
            let lineColor = new cv.Scalar(255, 0, 0)
            let circleColor = new cv.Scalar(255, 255, 255)
            cv.convexHull(cnt, hull, false, false)
            cv.convexityDefects(cnt, hull, defect)
            for(let i=0; i<defect.rows; i++){
                let start = new cv.Point(cnt.data32S[defect.data32S[i * 4] *2], cnt.data32S[defect.data32S[i * 4] *2 + 1])
                let end = new cv.Point(cnt.data32S[defect.data32S[i * 4 + 1] *2], cnt.data32S[defect.data32S[i * 4 + 1] *2 + 1])
                let far = new cv.Point(cnt.data32S[defect.data32S[i * 4 + 2] *2], cnt.data32S[defect.data32S[i * 4 + 2] *2 + 1])
                cv.line(dst, start, end, lineColor, 2, cv.LINE_AA, 0)
                cv.circle(dst, far, 3, circleColor, -1)
            }
            cv.imshow('output', dst)
        }

        function transpose(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            cv.threshold(src, src, 120, 200, cv.THRESH_BINARY)
            cv.transpose(src, dst)
            cv.imshow('output', dst)
        }

        function fitLine(){
            let src = cv.imread('shape')
            let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3)
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            cv.threshold(src, src, 177, 200, cv.THRESH_BINARY)
            let contours = new cv.MatVector()
            let hierarchy = new cv.Mat()
            let line = new cv.Mat()
            cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE)
            let cnt = contours.get(0)
            cv.fitLine(cnt, line, cv.DIST_L2, 0, 0.01, 0.01)
            let contoursColor = new cv.Scalar(255, 255, 255)
            let lineColor = new cv.Scalar(255, 0, 0)
            cv.drawContours(dst, contours, 0, contoursColor, 1, 8, hierarchy, 100)
            let vx = line.data32F[0]
            let vy = line.data32F[1]
            let x = line.data32F[2]
            let y = line.data32F[3]

            let lefty = Math.round((-x * vy / vx)+y)
            let righty = Math.round(((src.cols-x) *vy/vx) + y)

            let point1 = new cv.Point(src.cols-1, righty)
            let point2 = new cv.Point(0, lefty)
            cv.line(dst, point1, point2, lineColor, 2, cv.LINE_AA, 0)
            cv.imshow('output', dst)

        } 

        function boundEllipse(){
            let src = cv.imread('shape')
            let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3)
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            cv.threshold(src, src, 177, 200, cv.THRESH_BINARY)
            let contours = new cv.MatVector()
            let hierarchy = new cv.Mat()
            cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE)
            let cnt = contours.get(0)
            let rotatedRect = cv.fitEllipse(cnt)
            let contoursColor = new cv.Scalar(255, 255, 255)
            let circleColor = new cv.Scalar(255, 0, 0)
            cv.drawContours(dst, contours, 0, contoursColor, 1, 8, hierarchy, 100)
            cv.ellipse1(dst, rotatedRect, circleColor, 1, cv.LINE_8)
            cv.imshow('output', dst)
        }

        function boundCircle(){
            let src = cv.imread('shape')
            let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3)
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            cv.threshold(src, src, 177, 200, cv.THRESH_BINARY)
            let contours = new cv.MatVector()
            let hierarchy = new cv.Mat()
            cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE)
            let cnt = contours.get(0)
            let circle = cv.minEnclosingCircle(cnt)
            let contoursColor = new cv.Scalar(255, 255, 255)
            let circleColor = new cv.Scalar(255, 0, 0)
            cv.drawContours(dst, contours, 0, contoursColor, 1, 8, hierarchy, 100)
            cv.circle(dst, circle.center, circle.radius, circleColor)
            cv.imshow('output', dst)
        }

        function boundMinArea(){
            let src = cv.imread('lena')
            let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3)
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            cv.threshold(src, src, 177, 200, cv.THRESH_BINARY)
            let contours = new cv.MatVector()
            let hierarchy = new cv.Mat()
            cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE)
            let cnt = contours.get(0)
            let rotatedRect = cv.minAreaRect(cnt)
            let vertices = cv.RotatedRect.points(rotatedRect)
            let contoursColor = new cv.Scalar(255, 255, 255)
            let rectangleColor = new cv.Scalar(255, 0, 0)
            cv.drawContours(dst, contours, 0, contoursColor, 1, 8, hierarchy, 100)
            for(let i=0; i<4; i++){
                cv.line(dst, vertices[i], vertices[(i+1) % 4], rectangleColor, 2, cv.LINE_AA, 0)
            }
            cv.imshow('output', dst)
        }

        function boundRectangle(){
            let src = cv.imread('shape')
            let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3)
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            cv.threshold(src, src, 177, 200, cv.THRESH_BINARY)
            let contours = new cv.MatVector()
            let hierarchy = new cv.Mat()
            cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE)
            let contoursColor = new cv.Scalar(255, 255, 255)
            let rectangleColor = new cv.Scalar(255, 0, 0)
            let size = contours.size()
            draw(0)


            function draw(i){
                let cnt = contours.get(i)
                let rect = cv.boundingRect(cnt)
                cv.drawContours(dst, contours, 0, contoursColor, 1, 8, hierarchy, 100)
                let point1 = new cv.Point(rect.x, rect.y)
                let point2 = new cv.Point(rect.x+rect.width, rect.y+rect.height)
                cv.rectangle(dst, point1, point2, rectangleColor, 2, cv.LINE_AA, 0)
                cv.imshow('output', dst)
                i++
                if( i < size){
                    setTimeout(function(){
                        draw(i)
                    }, 100)
                }
            }

            

        }

        function convexHull(){
            let src = cv.imread('lena')
            let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3)
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            cv.threshold(src, src, 100, 200, cv.THRESH_BINARY)
            let contours = new cv.MatVector()
            let hierarchy = new cv.Mat()
            let hull = new cv.MatVector()
            cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE)
            for(let i=0; i<contours.size(); i++){
                let tmp = new cv.Mat()
                let cnt = contours.get(i)
                cv.convexHull(cnt, tmp, false, true)
                hull.push_back(tmp)
                cnt.delete()
                tmp.delete()
            }

            for(let i=0; i<contours.size(); i++){
                let colorHull = new cv.Scalar(Math.round(Math.random()*255), Math.round(Math.random()*255), Math.round(Math.random()*255))
                cv.drawContours(dst, hull, i, colorHull, 1, 8, hierarchy, 0)
            }
            cv.imshow('output', dst)

        }

        function moments(){
            let src = cv.imread('lena');
            let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
            cv.threshold(src, src, 100, 200, cv.THRESH_BINARY);
            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            let poly = new cv.MatVector()
            cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
            for(let i=0; i<contours.size(); i++){
                let tmp = new cv.Mat()
                let cnt =contours.get(i)
                cv.approxPolyDP(cnt, tmp, 3, true)
                poly.push_back(tmp)
                cnt.delete()
                tmp.delete()
            }

            for(let i=0; i<contours.size(); i++){
                let color = new cv.Scalar(Math.round(Math.random() * 255), Math.round(Math.random() * 255), Math.round(Math.random() * 255))
                cv.drawContours(dst, poly, i, color, 1, 8, hierarchy, 0)
            }

            cv.imshow('output', dst)
            // let cnt = contours.get(20);
        
            // You can try more different parameters
            // let Moments = cv.moments(cnt, false);
            // let area = cv.contourArea(cnt, false)
            // let perimeter = cv.arcLength(cnt, true)
        }

        function contours(){
            let src = cv.imread('lena')
            let dst = cv.Mat.zeros(src.cols, src.rows, cv.CV_8UC3)
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            cv.threshold(src, src, 100, 200, cv.THRESH_BINARY)
            let contours = new cv.MatVector()
            let hierarchy = new cv.Mat()
            cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE)
            for(let i=0; i<contours.size(); ++i){
                let color = new cv.Scalar(Math.round(Math.random()*255), Math.round(Math.random()*255), Math.round(Math.random()*255))
                cv.drawContours(dst, contours, i, color, 1, cv.LINE_8, hierarchy, 100)
            }
            cv.imshow('output', dst)
        }

        function pyramid(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            // cv.pyrDown(src, dst, new cv.Size(0, 0), cv.BORDER_DEFAULT)
            cv.pyrUp(src, dst, new cv.Size(0, 0), cv.BORDER_DEFAULT)
            let dst1 = new cv.Mat()
            cv.pyrUp(dst, dst1, new cv.Size(0, 0), cv.BORDER_DEFAULT)
            cv.imshow('output', dst1)
        }

        function Canny(){
            let src = cv.imread('lena')
            console.log(src)
            let dst = new cv.Mat()
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            cv.Canny(src, dst, 98, 100, 3, false)
            cv.imshow('output', dst)
        }

        function getStructuringElement(){
            let src = cv.imread('lena')
            cv.cvtColor(src, src, cv.COLOR_RGBA2RGB)
            let dst = new cv.Mat()
            let M = new cv.Mat()
            let ksize = new cv.Size(2, 2)
            M = cv.getStructuringElement(cv.MORPH_CROSS, ksize)
            cv.morphologyEx(src, dst, cv.MORPH_GRADIENT, M)
            cv.imshow('output', dst)
        }

        function gradient(){
            let src = cv.imread('lena')
            console.log(src)
            cv.cvtColor(src, src, cv.COLOR_RGBA2RGB)
            let dst = new cv.Mat()
            let M = cv.Mat.ones(5, 5, cv.CV_8U)
            // cv.morphologyEx(src, dst, cv.MORPH_GRADIENT, M)
            cv.morphologyEx(src, dst, cv.MORPH_TOPHAT, M)
            // cv.morphologyEx(src, dst, cv.MORPH_BLACKHAT, M)
            cv.imshow('output', dst)
        }
        
        function closing(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            let M = cv.Mat.ones(5, 5, cv.CV_8U)
            cv.morphologyEx(src, dst, cv.MORPH_CLOSE, M)
            cv.imshow('output', dst)
        }

        function opening(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            let M = cv.Mat.ones(5, 5, cv.CV_8U)
            let anchor = new cv.Point(-1, -1)
            cv.morphologyEx(src, dst, cv.MORPH_OPEN, M, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue())
            cv.imshow('output', dst)
        }

        function dilate(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            let anchor = new cv.Point(-1, -1)
            let M = cv.Mat.ones(50, 50, cv.CV_8U)
            cv.dilate(src, dst, M, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue())
            cv.imshow('output', dst)
        }

        function erode(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            let M = cv.Mat.ones(20, 20, cv.CV_8U)
            let anchor = new cv.Point(-1, -1)
            cv.erode(src, dst, M, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue())
            cv.imshow('output', dst)
        }

        function bilateralFilter(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            cv.cvtColor(src, src, cv.COLOR_RGBA2RGB, 0)
            cv.bilateralFilter(src, dst, 9, 75, 75, cv.BORDER_DEFAULT)
            cv.imshow('output', dst)
        }

        function medianBlur(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            cv.medianBlur(src, dst, 7)
            cv.imshow('output', dst)
        }

        function GaussianBlur(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            let ksize = new cv.Size(3, 3)
            cv.GaussianBlur(src, dst, ksize, 0, 0, cv.BORDER_DEFAULT)
            cv.imshow('output', dst)
        }
        
        function blur(){
            let src = cv.imread('lena')
            let dst= new cv.Mat()
            let M = cv.Mat.eye(3, 3, cv.CV_32FC1)
            let anchor = new cv.Point(-1, -1)
            cv.filter2D(src, dst, cv.CV_8U, M, anchor, 0, cv.BORDER_DEFAULT)
            cv.imshow('output', dst)
        }
        
        function threshold(){
            let src= cv.imread('lena')
            let dst = new cv.Mat()
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            cv.threshold(src, dst, 177, 200, cv.THRESH_BINARY)
            cv.imshow('output', dst)
        }
        
        function adaptiveThreshold(){
            let src= cv.imread('lena')
            let dst = new cv.Mat()
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0)
            cv.adaptiveThreshold(src, dst, 200, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 3, 2)
            cv.imshow('output', dst)
        }

        function resize(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            let dsize = new cv.Size(src.rows, src.cols)
            let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [56, 65, 368, 52, 28, 387, 389, 390])
            let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, 300, 0, 0, 300, 300, 300])
            let M = cv.getPerspectiveTransform(srcTri, dstTri)
            cv.warpPerspective(src, dst, M, dsize, cv.INTER_AREA, cv.BORDER_CONSTANT, new cv.Scalar())
            cv.imshow('output', dst)
        }

        function transform(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            let srcTri = cv.matFromArray(3, 1, cv.CV_32FC2, [0, 0, 0, 1, 1, 0])
            let dstTri = cv.matFromArray(3, 1, cv.CV_32FC2, [0.6, 0.2, 0.1, 1.3, 1.5, 0.3])
            let M = cv.getAffineTransform(srcTri, dstTri)
            let dsize = new cv.Size(src.rows, src.cols)
            cv.warpAffine(src, dst, M, dsize, cv.INTER_AREA, cv.BORDER_CONSTANT, new cv.Scalar())
            cv.imshow('output', dst)
        }

        function rotate(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            let dsize = new cv.Size(src.rows, src.cols)
            let center = new cv.Point(src.cols / 2, src.rows/2)
            let M = cv.getRotationMatrix2D(center, 45, 1)
            cv.warpAffine(src, dst, M, dsize, cv.INTER_AREA, cv.BORDER_CONSTANT, new cv.Scalar())
            cv.imshow('output', dst)
        }

        function translate(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            let M =cv.matFromArray(2, 3, cv.CV_64FC1, [1, 0, 50, 0, 1, 100])
            let dsize = new cv.Size(src.rows, src.cols)
            cv.warpAffine(src, dst, M, dsize, cv.INTER_AREA, cv.BORDER_CONSTANT, new cv.Scalar())
            cv.imshow('output', dst)
        }

        function scale(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            let dsize = new cv.Size(300, 300)
            cv.resize(src, dst, dsize, 0, 0, cv.INTER_AREA)
            cv.imshow('output', dst)

        }

        function setBound(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            let rows = src.rows
            let cols = src.cols
            let type = src.type()
            let min = new cv.Mat(rows, cols, type, [0, 0, 0, 0])
            let max = new cv.Mat(rows, cols, type, [150, 150, 150, 255])
            // 如果数组每个元素都在相应位置两个数组之间返回255，否则返回0
            cv.inRange(src, min, max, dst)
            cv.imshow('output', dst)
        }

        function rgb2gray(){
            let src = cv.imread('lena')
            let dst = new cv.Mat()
            cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0)
            cv.imshow('output', dst)

        }

        function imgBitwise(){
            let src = cv.imread('lena')
            let logo = src.roi(new cv.Rect(100, 100, 200, 200))
            // let roi = src.roi(new cv.Rect(100, 100, 200, 200))
            // let dst = new cv.Mat()
            // let mask = new cv.Mat()
            // let maskInv = new cv.Mat()
            // let imgBg = new cv.Mat()
            // let imgFg = new cv.Mat()
            // let sum = new cv.Mat()

            // cv.cvtColor(logo, mask, cv.COLOR_RGBA2GRAY, 0)
            // cv.threshold(mask, mask, 100, 255, cv.THRESH_BINARY)
            // cv.bitwise_not(mask, maskInv)

            // cv.bitwise_and(roi, roi, imgBg, maskInv)
            // cv.bitwise_and(logo, logo, imgFg, mask)

            // cv.add(imgBg, imgFg, sum)

            dst = src.clone()
            for(let i=0; i<logo.rows; i++){
                for(let j=0; j<logo.cols; j++){
                    dst.ucharPtr(i, j)[0] = logo.ucharPtr(i, j)[2]
                }
            }

            cv.imshow('output', dst)
        }
        function blendImg(){
            let src1 = cv.imread('img1')
            let src2 = cv.imread('img2')
            // 图片混合
            let dst = new cv.Mat()
            cv.addWeighted(src1, 0.2, src2, 0.8, 0.0, dst, -1)

            // roi
            let rect = new cv.Rect(100, 100, 200, 200)
            dst = src1.roi(rect)

            // border
            dst = new cv.Mat()
            cv.copyMakeBorder(src1, dst, 10, 10, 10, 10, cv.BORDER_CONSTANT, new cv.Scalar(255, 0, 0, 255))

            // add
            dst = new cv.Mat()
            let mask = new cv.Mat()
            cv.add(src1, src2, dst, mask, -1)

            // 减
            dst = new cv.Mat()
            mask = new cv.Mat()
            cv.subtract(src1, src2, dst, mask, -1)

            
            cv.imshow('output', dst)
            dst.delete()
            src1.delete()
            src2.delete()
        }
    </script>
</body>
</html>